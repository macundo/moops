#ifndef MULTIPOLE_TAYLOR_HPP
#define MULTIPOLE_TAYLOR_HPP

#include <cmath>
#include <cassert>
#include <algorithm>

#include "math/fluid_solver/stokes/fmm/multipole_taylor_storage.hpp"

template < typename value_type, int precision = 3 >
class MultipoleTaylor
{
    private:

        multipole_taylor_storage<value_type, precision> m_storage;
        enum
        {
            m_precision = precision,
            m_num_coefficients = multipole_taylor_storage<value_type, precision>::num_coefficients
        };

    public:

        MultipoleTaylor(size_t tree_size) :m_storage(tree_size) {}

        value_type *phi(int i, int j) { return m_storage.phi(i,j); }
        value_type *psi(int i, int j) { return m_storage.psi(i,j); }

        ///
        /// @brief Compute the far field expansion of the box and update the coefficients array
        /// @param box
        ///
        template<typename box_type>
        void compute_far_field_expansions(const box_type *box, size_t j)
        {
            typedef typename box_type::const_box_iterator box_iterator;
            ///< Start at the botom
            for (box_iterator b = box->children().begin(), end = box->children().end(); b != end; ++b)
            {
#pragma omp task firstprivate(b,j)
                compute_far_field_expansions(*b,j);
            }
#pragma omp taskwait
            value_type coeff[m_num_coefficients] = {0};
            value_type *phi = m_storage.phi(box->idx(),j);
            ///< If the box is childless, form a multipole expansion about its center from all charges in the box
            if (box->children().size() == 0)
                multipole_expansion(box,coeff,j);
            ///< If this box is a parent(other than root), form a multipole expansion about its center by merging multipole expansions from its children
            else if (box->level() > 0)
                shift_multipole_expansion(box,coeff,j);
            ///< Accumulate values, update far field expansion coefficients
            for (int i = 0; i < m_num_coefficients; ++i)
                phi[i] += coeff[i];
        }

        ///
        /// @brief Compute the near field expansion of the box and update the coefficients array
        /// @param box
        ///
        template<typename box_type>
        void compute_local_expansions(const box_type *box, size_t j)
        {
            typedef typename box_type::const_box_iterator box_iterator;
            value_type coeff[m_num_coefficients] = {0};
            value_type *psi = m_storage.psi(box->idx(), j);
            ///< If box is not root, convert multipole to local expansion and shift
            if (box->level() > 1)
            {
                multipole_to_local_expansion(box,coeff,j);
                shift_local_expansion(box,coeff,j);
                ///< Scale the coefficients if box is childless
                if (box->children().size() == 0)
                    std::transform(coeff,coeff+m_num_coefficients,m_storage.ijk_factorial(),coeff,std::multiplies<value_type>());
            }
            ///< Accumulate values, update near field expansion coefficients
            std::transform(psi,psi+m_num_coefficients,coeff,psi,std::plus<value_type>());

            for (box_iterator b = box->children().begin(), end = box->children().end(); b != end; ++b)
            {
#pragma omp task firstprivate(b,j)
                compute_local_expansions(*b, j);
            }
#pragma omp taskwait

        }

        ///
        /// @brief Represents the potential generated by all charges in box2 and is valid in box1
        ///
        /// @param box1 Box in which to generate local expansion
        /// @param box2 Box far away from box1
        /// @param coeff The local expansion coefficients
        ///
        template<typename box_type>
        inline void local_expansion(const box_type *box1, const box_type *box2, value_type *coeff)
        {
            /*
             *     Initialize Psi' as specified by Theorem 3.2.2.
             */
            value_type dx[3] = {box1->x() - box2->x(), box1->y() - box2->y(), box1->z() - box2->z() };
            value_type r = std::sqrt(dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2]);
            value_type tau[3] = { 2.0*(dx[0] / r), 2.0*(dx[1] / r), 2.0*(dx[2] / r) };
            value_type powers[3][m_precision+1];
            value_type r0[m_precision+1];

            for (int j = 0; j <= m_precision; ++j)
            {
                for (int i = 0; i < 3; ++i)
                    powers[i][j] = std::pow(tau[i], j);
                r0[j] = 1.0 / std::pow(r, j + 1);
            }

            for (int i = 0, idx = 0; i <= m_precision; ++i)
                for (int j = 0; j <= m_precision - i ; ++j)
                    for (int k = 0; k <= m_precision - i - j ; ++k, ++idx)
                    {
                        value_type sum = 0.0;
                        for (int a = 0; a <= (i / 2); ++a)
                            for (int b = 0; b <= (j / 2); ++b)
                                for (int g = 0; g <= (k / 2); ++g)
                                    sum += m_storage.ijk_binomial(m_storage.tetra_three(i - a) - m_storage.tetra_two(i - a + j - b) + k - g) * m_storage.binomial(i - a, a) * m_storage.binomial(j - b, b) * m_storage.binomial(k - g, g) * powers[0][i-2*a] * powers[1][j-2*b] * powers[2][k-2*g];
                        coeff[idx] = sum*(i + j + k & 1 ? -1 : 1) * r0[i+j+k] / m_storage.ijk_factorial(idx);
                    }
        }

        ///
        /// @brief Represents the potential generated by charges contained inside current box and is valid everywhere outside the box
        ///
        /// @param box Box in which to generate the multipole expansion
        /// @param coeff The multipole expansion coefficients
        ///
        template<typename box_type>
        inline void box_multipole_expansion(const box_type *box, value_type *coeff)
        {
            assert(box->parent());
            value_type powers[3][m_precision+1];

            /*
             *     Initialize Phi' as specified by Theorem 3.2.1.
             */
            value_type dx[3] = { box->x() - box->parent()->x(), box->y() - box->parent()->y(), box->z() - box->parent()->z() };
            for (int i = 0; i < 3; ++i)
                for (int j = 0; j <= m_precision; ++j)
                    powers[i][j] = std::pow(dx[i], j);

            for (int i = 0, idx = 0; i <= m_precision; ++i)
                for (int j = 0; j <= m_precision - i; ++j)
                    for (int k = 0; k <= m_precision - i - j; ++k, ++idx)
                        coeff[idx] = m_storage.ijk_factorial(idx) * powers[0][i] * powers[1][j] * powers[2][k];

        }

        ///
        /// @brief Form a multipole expansion about box center from all charges within the box, valid outside the box
        /// @param Node Current box
        ///
        template<typename box_type>
        inline void multipole_expansion(const box_type *box, value_type *coeff, size_t l)
        {
            typedef typename box_type::const_particle_iterator particle_iterator;
            value_type powers[3][m_precision+1];
            /*
             * Form multipole expansions of potential field due to particles
             * in each cube about the cube center at the leaf nodes.
             */
            for (particle_iterator p = box->particles().begin(), end = box->particles().end(); p != end; ++p)
            {
                value_type fdotx = (*p)->position[0]*(*p)->force[0]+(*p)->position[1]*(*p)->force[1]+(*p)->position[2]*(*p)->force[2];
                value_type f[4] = {(*p)->force[0],(*p)->force[1],(*p)->force[2],fdotx};
                value_type dx[3] = {(*p)->position[0] - box->x(), (*p)->position[1] - box->y(), (*p)->position[2] - box->z() };
                for (int i = 0; i < 3; ++i)
                    for (int j = 0; j <= m_precision; ++j)
                        powers[i][j] = std::pow(dx[i], j);

                for (int i = 0, idx = 0; i <= m_precision; ++i)
                    for (int j = 0; j <= m_precision - i; ++j)
                        for (int k = 0; k <= m_precision - i - j; ++k, ++idx)
                            coeff[idx] = f[l]*((i + j + k) & 1 ? -1 : 1) * m_storage.ijk_factorial(idx) * powers[0][i] * powers[1][j] * powers[2][k];
            }
        }


        /**
         * @brief Form a multipole expansion about the box center by merging multipole expansions from its children
         * @param Node
        **/
        template<typename box_type>
        inline void shift_multipole_expansion(const box_type *box, value_type *coeff, size_t l)
        {
            typedef typename box_type::const_box_iterator box_iterator;
            // Space to store children multipole expansions
            value_type local_phi[m_num_coefficients];
            value_type *child_phi;

            for (box_iterator b = box->children().begin(), end = box->children().end(); b != end; ++b)
            {
                box_multipole_expansion(*b, local_phi);
                child_phi = m_storage.phi((*b)->idx(),l);
                for (int i = 0, idx = 0; i <= m_precision; ++i)
                    for (int j = 0; j <= m_precision - i; ++j)
                        for (int k = 0; k <= m_precision - i - j; ++k, ++idx)
                        {
                            value_type sum = 0.0;
                            for (int a = 0; a <= i; ++a)
                                for (int b = 0; b <= j; ++b)
                                    for (int g = 0; g <= k; ++g)
                                        sum += child_phi[m_storage.tetra_three(a)-m_storage.tetra_two(a+b)+g]*local_phi[m_storage.tetra_three(i-a)-m_storage.tetra_two(i-a+j-b) +k-g];
                            coeff[idx] = sum;
                        }
            }
        }
        /**
         * @brief Shift center of parent local expansion to its children and add the translated expansions to children's local expansions
         * @param box
        **/

        template<typename box_type>
        void shift_local_expansion(const box_type *box, value_type *coeff, size_t l)
        {
            assert(box->parent());
            value_type dx[3] = {box->x()-box->parent()->x(), box->y()-box->parent()->y(), box->z()-box->parent()->z() };
            value_type powers[3][m_precision+1];
            value_type *parent_psi = m_storage.psi(box->parent()->idx(),l);

            for (int i = 0; i < 3; ++i)
                for (int j = 0; j <= m_precision; ++j)
                    powers[i][j] = std::pow(dx[i], j);

            for (int i = 0, idx = 0; i <= m_precision; ++i)
                for (int j = 0; j <= m_precision - i; ++j)
                    for (int k = 0; k <= m_precision - i - j; ++k, ++idx)
                    {
                        int n = i + j + k;
                        value_type sum = 0.0;
                        for (int a = 0; a <= m_precision-n; ++a)
                            for (int b = 0; b <= m_precision-n-a; ++b)
                                for (int g = 0; g <= m_precision-n-a-b; ++g)
                                    sum += parent_psi[m_storage.tetra_three(i+a)-m_storage.tetra_two(j+b) +k+g]*m_storage.ijk_factorial(m_storage.tetra_three(a)-m_storage.tetra_two(b) +g) *powers[0][a]*powers[1][b]*powers[2][g];
                        coeff[idx] += sum;
                    }
        }

        /**
         * @brief Form a local expansion by converting the multipole expansion of each cube in
         *         the interaction-field of the current cube to a local expansion about the center of the cube.
         * @param Node
         **/
        template<typename box_type>
        void multipole_to_local_expansion(const box_type *box, value_type *coeff, size_t l)
        {
            typedef typename box_type::const_box_iterator box_iterator;
            value_type neighbor_psi[m_num_coefficients];
            value_type *neighbor_phi;
            /*
             * Form a local expansion by using the `Conversion of Multipole
             * into a Local Expansion' lemma to convert the multipole
             * expansion of each cube in the interaction-field of the
             * current cube to a local expansion about the center of the
             * cube.
             */
            for (box_iterator b = box->lists(1).begin(), end = box->lists(1).end(); b != end; ++b)
            {
                local_expansion(*b,box,neighbor_psi);
                neighbor_phi = m_storage.phi((*b)->idx(),l);

                for (int i = 0, idx = 0; i <= m_precision; ++i)
                    for (int j = 0; j <= m_precision - i; ++j)
                        for (int k = 0; k <= m_precision - i - j; ++k, ++idx)
                        {
                            int n = i + j + k;
                            value_type sum = 0.0;
                            for (int a = 0; a <= m_precision-n; ++a)
                                for (int b = 0; b <= m_precision-n-a; ++b)
                                    for (int g = 0; g <= m_precision-n-a-b; ++g)
                                        sum += neighbor_phi[m_storage.tetra_three(a)-m_storage.tetra_two(b) +g]*neighbor_psi[m_storage.tetra_three(i+a)-m_storage.tetra_two(j+b) +k+g];
                            coeff[idx] = sum;
                        }
            }
        }


        /**
         * @brief Update total velocities in current box and it childs recursivelly
         *
         * @param box current box
         * @param delta regularization parameter
         **/
        template<typename box_type>
        void compute_velocity(box_type *box, value_type delta)
        {
            typedef typename box_type::const_box_iterator box_iterator;
            compute_near_field_velocities(box,delta);
            if (box->children().size() == 0)
                compute_far_field_velocities(box);

            for (box_iterator b = box->children().begin(), end = box->children().end(); b != end; ++b)
            {
#pragma omp task firstprivate(b,delta)
                compute_velocity(*b, delta);
            }
#pragma omp taskwait
        }


        /**
         * @brief Update velocities inside box due to direct interactions
         *
         * @param box current box
         * @param delta regularization parameter
         **/
        template<typename box_type>
        void compute_near_field_velocities(box_type *box, value_type delta)
        {
            typedef typename box_type::particle_iterator particle_iterator;
            typedef typename box_type::box_iterator box_iterator;
            for (box_iterator b = box->lists(3).begin(), b_end = box->lists(3).end(); b != b_end; ++b)
                for (particle_iterator p1 = box->particles().begin(), p1_end = box->particles().end(); p1 != p1_end; ++p1)
                    for (particle_iterator p2 = (*b)->particles().begin(), p2_end = (*b)->particles().end(); p2 != p2_end; ++p2)
                        update_velocity((*p1)->position, (*p1)->velocity, (*p2)->position, (*p2)->force, delta);

            if (box->children().size() == 0)
            {
                for (particle_iterator p1 = box->particles().begin(), p1_end = box->particles().end(); p1 != p1_end; ++p1)
                    for (particle_iterator p2 = box->particles().begin(), p2_end = box->particles().end(); p2 != p2_end; ++p2)
                        update_velocity((*p1)->position, (*p1)->velocity, (*p2)->position, (*p2)->force, delta);

                for (box_iterator b = box->lists(0).begin(), b_end = box->lists(0).end(); b != b_end; ++b)
                    for (particle_iterator p1 = box->particles().begin(), p1_end = box->particles().end(); p1 != p1_end; ++p1)
                        for (particle_iterator p2 = (*b)->particles().begin(), p2_end = (*b)->particles().end(); p2 != p2_end; ++p2)
                            update_velocity((*p1)->position, (*p1)->velocity, (*p2)->position, (*p2)->force, delta);

                for (box_iterator b = box->lists(2).begin(), b_end = box->lists(2).end(); b != b_end; ++b)
                    for (particle_iterator p1 = box->particles().begin(), p1_end = box->particles().end(); p1 != p1_end; ++p1)
                        for (particle_iterator p2 = (*b)->particles().begin(), p2_end = (*b)->particles().end(); p2 != p2_end; ++p2)
                            update_velocity((*p1)->position, (*p1)->velocity, (*p2)->position, (*p2)->force, delta);
            }

        }


        /**
         * @brief Update velocities due to the far field expansions
         *
         * @param box current box
         **/
        template<typename box_type>
        void compute_far_field_velocities(box_type *box)
        {
            value_type dx[3];
            value_type powers[3][m_precision+1];
            value_type dpowers[3][m_precision+1];
            value_type *psi0 = m_storage.psi(box->idx(), 0);
            value_type *psi1 = m_storage.psi(box->idx(), 1);
            value_type *psi2 = m_storage.psi(box->idx(), 2);
            value_type *psi3 = m_storage.psi(box->idx(), 3);

            typedef typename box_type::particle_iterator particle_iterator;
            for (particle_iterator p = box->particles().begin(), end = box->particles().end(); p != end; ++p)
            {
                for (int i = 0; i < 3; ++i)
                {
                    dx[i] = (*p)->position[i]-box->coords(i);
                    for (int j = 0 ; j <= m_precision; ++j)
                    {
                        powers[i][j] = std::pow(dx[i],j);
                        dpowers[i][j] = j*std::pow(dx[i],j-1);
                    }
                }
                value_type expansion[3][5] = {0};
                for (int i = 0, idx = 0; i <= m_precision; ++i)
                    for (int j = 0; j <= m_precision - i; ++j)
                        for (int k = 0; k <= m_precision - i - j; ++k, ++idx)
                        {
                            expansion[0][0] += psi0[idx]*powers[0][i]*powers[1][j]*powers[2][k];
                            expansion[1][0] += psi1[idx]*powers[0][i]*powers[1][j]*powers[2][k];
                            expansion[2][0] += psi2[idx]*powers[0][i]*powers[1][j]*powers[2][k];

                            expansion[0][1] += psi0[idx]*dpowers[0][i]*powers[1][j]*powers[2][k];
                            expansion[1][1] += psi0[idx]*powers[0][i]*dpowers[1][j]*powers[2][k];
                            expansion[2][1] += psi0[idx]*powers[0][i]*powers[1][j]*dpowers[2][k];

                            expansion[0][2] += psi1[idx]*dpowers[0][i]*powers[1][j]*powers[2][k];
                            expansion[1][2] += psi1[idx]*powers[0][i]*dpowers[1][j]*powers[2][k];
                            expansion[2][2] += psi1[idx]*powers[0][i]*powers[1][j]*dpowers[2][k];

                            expansion[0][3] += psi2[idx]*dpowers[0][i]*powers[1][j]*powers[2][k];
                            expansion[1][3] += psi2[idx]*powers[0][i]*dpowers[1][j]*powers[2][k];
                            expansion[2][3] += psi2[idx]*powers[0][i]*powers[1][j]*dpowers[2][k];

                            expansion[0][4] += psi3[idx]*dpowers[0][i]*powers[1][j]*powers[2][k];
                            expansion[1][4] += psi3[idx]*powers[0][i]*dpowers[1][j]*powers[2][k];
                            expansion[2][4] += psi3[idx]*powers[0][i]*powers[1][j]*dpowers[2][k];
                        }
                (*p)->velocity[0] += expansion[0][0] - (*p)->position[0]*expansion[0][1] - (*p)->position[1]*expansion[0][2] - (*p)->position[2]*expansion[0][3] + expansion[0][4];
                (*p)->velocity[1] += expansion[1][0] - (*p)->position[0]*expansion[1][1] - (*p)->position[1]*expansion[1][2] - (*p)->position[2]*expansion[1][3] + expansion[1][4];
                (*p)->velocity[2] += expansion[2][0] - (*p)->position[0]*expansion[2][1] - (*p)->position[1]*expansion[2][2] - (*p)->position[2]*expansion[2][3] + expansion[2][4];
            }

        }

        /**
         * @brief Update the velocity at target position due to a force at source position using a regularized stokeslet.
         *
         * @param target position of velocity
         * @param velocity velocity vector to update
         * @param source position of the force
         * @param force force vector
         * @param delta regularization parameter
         **/
        void update_velocity(const value_type *target, value_type *velocity, const value_type *source, const value_type *force, value_type delta)
        {
            value_type dx[3] = {target[0] - source[0],target[1] - source[1],target[2] - source[2]};

            value_type r2 = dx[0] * dx[0] + dx[1] * dx[1] + dx[2] * dx[2];
            value_type d2 = delta * delta;
            value_type R1 = r2 + d2;
            value_type R2 = R1 + d2;
            value_type invR = 1.0/R1;
            value_type H = sqrt(invR) *invR;

            value_type fdx = (force[0]*dx[0]+force[1]*dx[1]+force[2]*dx[2]);

            velocity[0] += H* (force[0]*R2+fdx*dx[0]);
            velocity[1] += H* (force[1]*R2+fdx*dx[1]);
            velocity[2] += H* (force[2]*R2+fdx*dx[2]);
        }

        template<typename output_type>
        friend output_type & operator<< (output_type & o, MultipoleTaylor const &fmm)
        {
            for (size_t i = 0, end = fmm.m_storage.coeff_size()/(4*fmm.m_num_coefficients); i < end; ++i)
            {
                o << "Box id: " << i << std::endl;
                for (int j = 0; j < 4; ++j)
                {
                    const value_type *phi = fmm.m_storage.phi(i,j);
                    o << "phi[" << j << "] = [";
                    for (int k = 0; k < fmm.m_num_coefficients; ++k)
                        o << phi[k] << ",";
                    o << "]" << std::endl;
                }
                o << "---" << std::endl;
                for (int j = 0; j < 4; ++j)
                {
                    const value_type *psi = fmm.m_storage.psi(i,j);
                    o << "psi[" << j << "] = [";
                    for (int k = 0; k < fmm.m_num_coefficients; ++k)
                        o << psi[k] << ",";
                    o << "]" << std::endl;
                }

            }
            return o;
        }


};


#endif

